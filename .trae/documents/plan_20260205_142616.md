# Android 播放录音文本同步高亮 - 高性能方案

针对 **10MB 纯文本（无分段）**、**高性能**、**双向同步** 的需求，普通的 `TextView` 或 `SpannableString` 无法满足（会导致 OOM 或卡顿）。我建议采用 **自定义 View + 虚拟化渲染** 的方案。

## 核心设计思路

### 1. 数据结构设计 (避免 OOM)

* **文本存储**: 10MB 文本不要一次性加载进 `SpannableString`。保持为 `String` 或 `char[]` 即可（占用约 20MB 内存，可接受）。

* **索引映射**: 需要一个高效的索引结构 `List<WordSpan>` 来存储 `startTime`, `endTime`, `charStart`, `charEnd`。

  * 使用 **二分查找** (Binary Search) 来快速根据 **时间** 找 **文字位置**。

  * 使用 **二分查找** 来快速根据 **文字位置** 找 **时间**。

### 2. UI 渲染方案 (自定义 View)

创建一个 `SubtitleSyncView` 继承自 `View`。

* **虚拟滚动 (Virtual Scrolling)**:

  * 既然文本有 10MB，无法一次性计算完整的高度 (`StaticLayout` 处理 10MB 会卡死)。

  * **策略**: 只计算和绘制 **当前屏幕可见区域** 的文本。

  * 维护一个 `currentScrollOffset` (字符偏移量)，表示当前屏幕第一行显示的文字在全文中的位置。

  * 在 `onDraw` 中，截取 `currentScrollOffset` 后的一段文本（例如 2000 字符），创建临时的 `StaticLayout` 进行绘制。

* **无缝连接**:

  * 为了保证 "不能强行断句"，我们需要在截取文本时，向前寻找最近的 **空格/标点** 作为起始点，避免单词被截断。

### 3. 功能实现细节

* **高亮实现 (Requirement 3, 8)**:

  * 不修改文本内容，而是在 `onDraw` 时，判断当前绘制的字符是否在 "高亮时间区间" 内。如果是，设置 `TextPaint` 的颜色为高亮色，否则为普通色。

* **点击跳转 (Requirement 4)**:

  * 监听 `onTouchEvent`，获取点击的 (x, y)。

  * 通过 `StaticLayout.getOffsetForHorizontal` 获取行内的字符偏移。

  * 结合 `currentScrollOffset` 算出全局字符索引 -> 查表 -> 获取 `startTime` -> Seek 播放器。

* **滚动条同步 (Requirement 5)**:

  * 滚动条进度 = `currentScrollOffset` / `totalTextLength`。

  * 拖动滚动条 -> 更新 `currentScrollOffset` -> `invalidate()` 重绘。

## 潜在风险与对策 (查缺补漏)

1. **滚动条抖动**: 由于我们只渲染可见区域，精确的 "总高度" 是未知的。我们将使用 **字符比例** 来模拟滚动条位置，而不是像素高度。这对于长文本是标准做法。
2. **断行问题**: "全部文本连续，无分段"。这意味着没有 `\n`。`StaticLayout` 会自动换行。我们需要确保 "虚拟窗口" 移动时，行与行之间的视觉连续性。

   * *解决方案*: 每次绘制时，确保起始位置是行首（可以通过向前回溯到上一个换行点或由 StaticLayout 预计算每行的字符数，但这对于 10MB 太慢）。

   * *优化*: 我们可以容忍首行可能从非行首开始绘制（稍微向左偏移），或者简单地按单词边界截取。

## 待确认项

* 是否已有 ASR 数据格式？(假设是 JSON 数组，包含 start, end, text/word)。

  * starttime
  * endtime
  * content

* 播放器是否已选定？(MediaPlayer / ExoPlayer)。方案通用，只需提供回调。

  * ExoPlayer

确认方案后，我将开始实现核心的 `SubtitleSyncView` 和数据管理器。
